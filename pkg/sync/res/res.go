//
// Copyright (c) Zhou Peng <p@ctriple.cn>
//
package res

import (
	"fmt"
	"hash/fnv"
	"html/template"
	"os"
	"path"

	"github.com/ctriple/drbd/pkg/defs"
)

const resTemplate = `#
# AUTO-GENERATED BY ctriple.cn/drbd
#           DO NOT EDIT
#
resource {{.ResName}} {

{{range .Nodes}}

  on {{.Name}} {
    node-id   {{.ID}};
    device    {{.Device}};
    disk      {{.Disk}};
    address   {{.Address}};
    meta-disk internal;
  }

{{end}}

  connection-mesh {
    hosts {{range .Nodes}} {{.Name}}{{end}};
  }

  net {
    protocol  C;
    csums-alg crc32c;
  }

}
`

// nr use hash algorithm to map resource name to a range of integer.
func nr(resName string) int {
	h := fnv.New32a()
	h.Write([]byte(resName))
	n := h.Sum32()

	nr := n % (defs.DrbdPortMax - defs.DrbdPortMin)

	return int(nr)
}

// FIXME: Should have been const, but var is easy for testing
var (
	resOutDir  = "/etc/drbd.d"
	devDrbdFmt = "/dev/drbd%d"
)

type node struct {
	ID      int
	Name    string
	Device  string
	Disk    string
	Address string
}

func New(resName, disk string, hosts, ips []string) error {
	nr := nr(resName)
	dev := fmt.Sprintf(devDrbdFmt, nr)

	var nodes []node
	for i, h := range hosts {
		addr := fmt.Sprintf("%s:%d", ips[i], defs.DrbdPortMin+nr)

		n := node{
			ID:      i,
			Name:    h,
			Device:  dev,
			Disk:    disk,
			Address: addr,
		}
		nodes = append(nodes, n)
	}

	resFile := path.Join(resOutDir, resName+".res")
	writer, err := os.OpenFile(resFile, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0644)
	if err != nil {
		return err
	}
	defer writer.Close()

	resTmpl := template.Must(template.New(resName).Parse(resTemplate))
	data := struct {
		ResName string
		Nodes   []node
	}{
		ResName: resName,
		Nodes:   nodes,
	}
	if err := resTmpl.Execute(writer, data); err != nil {
		return err
	}

	return nil
}

func Del(resName string) error {
	resFile := path.Join(resOutDir, resName+".res")
	if err := os.Remove(resFile); err != nil {
		return err
	}

	return nil
}
